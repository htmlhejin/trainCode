<script>
    // 每一个函数中必定有一个prototype属性，这个属性的值是对象，这个对象叫原型对象，
    // 每个对象中又必定有一个constructor属性，这个属性的值指向这个函数本身
    // function f(){}
    // console.log(f.prototype.constructor==f)   //true

    // console.log(Array==Array.prototype.constructor)  //true


    // 每个对象中必定有一个__proto__属性，这个属性的值是对象，该对象叫隐式原型
    // let obj={}
    // console.log(obj)  //__proto__: Object

    // let arr=[]
    // console.log(arr)   //__proto__: Array(0)

    // function f(){}
    // console.log(f)

    // 对象的__proto__属性的值，指向创建这个对象的函数的prototype
    // let obj = {name:"wangcai"}  // 通过Object创建
    // console.log(obj)
    // console.log(obj.__proto__ == Object.prototype)  // true

    // 如果访问一个对象的属性时，先在这个对象自己的属性中去找，如果找不到，则沿着__proto__这个属性向中找，
    // 如果__proto__这个对象中还是没有找到，就在__proto__对象的__proto__属性中去找，依次下去，这就是原型链。
    // function F(){}
    // let f1=new F()
    // console.log(f1.__proto__)   
    // // console.log(f.__proto__)
    // // console.log(f.__proto__)

    // let arr=[1,2,3]
    // console.log(arr)
    // console.log(arr.__proto__==Array.prototype)   //true
    // console.log(arr.toString)    //自己的属性中没有toString这个属性，那么在__proto__属性中找，找了一级就找到了

    // 对象中没有某个属性，我们可以自己创建一个属性
    let a=[1,2,3]
    Array.prototype.abc=function(){
        console.log("a....")
    }
    a.abc()   //abc指向一个函数，所以找abc属性时，后面需要加(),表示调用这个函数
</script>